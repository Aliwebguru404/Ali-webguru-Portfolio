{"ast":null,"code":"import _defineProperty from \"C:/Users/Shoaib Ali/OneDrive/Documents/GitHub/Ali-webguru-Portfolio/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { animateCSSModeScroll } from '../../shared/utils.js';\nexport default function slideTo(index, speed, runCallbacks, internal, initial) {\n  if (index === void 0) {\n    index = 0;\n  }\n\n  if (speed === void 0) {\n    speed = this.params.speed;\n  }\n\n  if (runCallbacks === void 0) {\n    runCallbacks = true;\n  }\n\n  if (typeof index !== 'number' && typeof index !== 'string') {\n    throw new Error(\"The 'index' argument cannot have type other than 'number' or 'string'. [\".concat(typeof index, \"] given.\"));\n  }\n\n  if (typeof index === 'string') {\n    /**\r\n     * The `index` argument converted from `string` to `number`.\r\n     * @type {number}\r\n     */\n    var indexAsNumber = parseInt(index, 10);\n    /**\r\n     * Determines whether the `index` argument is a valid `number`\r\n     * after being converted from the `string` type.\r\n     * @type {boolean}\r\n     */\n\n    var isValidNumber = isFinite(indexAsNumber);\n\n    if (!isValidNumber) {\n      throw new Error(\"The passed-in 'index' (string) couldn't be converted to 'number'. [\".concat(index, \"] given.\"));\n    } // Knowing that the converted `index` is a valid number,\n    // we can update the original argument's value.\n\n\n    index = indexAsNumber;\n  }\n\n  var swiper = this;\n  var slideIndex = index;\n  if (slideIndex < 0) slideIndex = 0;\n  var params = swiper.params,\n      snapGrid = swiper.snapGrid,\n      slidesGrid = swiper.slidesGrid,\n      previousIndex = swiper.previousIndex,\n      activeIndex = swiper.activeIndex,\n      rtl = swiper.rtlTranslate,\n      wrapperEl = swiper.wrapperEl,\n      enabled = swiper.enabled;\n\n  if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {\n    return false;\n  }\n\n  var skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);\n  var snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);\n  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n\n  if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {\n    swiper.emit('beforeSlideChangeStart');\n  }\n\n  var translate = -snapGrid[snapIndex]; // Update progress\n\n  swiper.updateProgress(translate); // Normalize slideIndex\n\n  if (params.normalizeSlideIndex) {\n    for (var i = 0; i < slidesGrid.length; i += 1) {\n      var normalizedTranslate = -Math.floor(translate * 100);\n      var normalizedGrid = Math.floor(slidesGrid[i] * 100);\n      var normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);\n\n      if (typeof slidesGrid[i + 1] !== 'undefined') {\n        if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {\n          slideIndex = i;\n        } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {\n          slideIndex = i + 1;\n        }\n      } else if (normalizedTranslate >= normalizedGrid) {\n        slideIndex = i;\n      }\n    }\n  } // Directions locks\n\n\n  if (swiper.initialized && slideIndex !== activeIndex) {\n    if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {\n      return false;\n    }\n\n    if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {\n      if ((activeIndex || 0) !== slideIndex) return false;\n    }\n  }\n\n  var direction;\n  if (slideIndex > activeIndex) direction = 'next';else if (slideIndex < activeIndex) direction = 'prev';else direction = 'reset'; // Update Index\n\n  if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {\n    swiper.updateActiveIndex(slideIndex); // Update Height\n\n    if (params.autoHeight) {\n      swiper.updateAutoHeight();\n    }\n\n    swiper.updateSlidesClasses();\n\n    if (params.effect !== 'slide') {\n      swiper.setTranslate(translate);\n    }\n\n    if (direction !== 'reset') {\n      swiper.transitionStart(runCallbacks, direction);\n      swiper.transitionEnd(runCallbacks, direction);\n    }\n\n    return false;\n  }\n\n  if (params.cssMode) {\n    var isH = swiper.isHorizontal();\n    var t = rtl ? translate : -translate;\n\n    if (speed === 0) {\n      var isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n\n      if (isVirtual) {\n        swiper.wrapperEl.style.scrollSnapType = 'none';\n        swiper._immediateVirtual = true;\n      }\n\n      wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;\n\n      if (isVirtual) {\n        requestAnimationFrame(function () {\n          swiper.wrapperEl.style.scrollSnapType = '';\n          swiper._swiperImmediateVirtual = false;\n        });\n      }\n    } else {\n      var _wrapperEl$scrollTo;\n\n      if (!swiper.support.smoothScroll) {\n        animateCSSModeScroll({\n          swiper: swiper,\n          targetPosition: t,\n          side: isH ? 'left' : 'top'\n        });\n        return true;\n      }\n\n      wrapperEl.scrollTo((_wrapperEl$scrollTo = {}, _defineProperty(_wrapperEl$scrollTo, isH ? 'left' : 'top', t), _defineProperty(_wrapperEl$scrollTo, \"behavior\", 'smooth'), _wrapperEl$scrollTo));\n    }\n\n    return true;\n  }\n\n  swiper.setTransition(speed);\n  swiper.setTranslate(translate);\n  swiper.updateActiveIndex(slideIndex);\n  swiper.updateSlidesClasses();\n  swiper.emit('beforeTransitionStart', speed, internal);\n  swiper.transitionStart(runCallbacks, direction);\n\n  if (speed === 0) {\n    swiper.transitionEnd(runCallbacks, direction);\n  } else if (!swiper.animating) {\n    swiper.animating = true;\n\n    if (!swiper.onSlideToWrapperTransitionEnd) {\n      swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {\n        if (!swiper || swiper.destroyed) return;\n        if (e.target !== this) return;\n        swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\n        swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);\n        swiper.onSlideToWrapperTransitionEnd = null;\n        delete swiper.onSlideToWrapperTransitionEnd;\n        swiper.transitionEnd(runCallbacks, direction);\n      };\n    }\n\n    swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\n    swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);\n  }\n\n  return true;\n}","map":{"version":3,"sources":["C:/Users/Shoaib Ali/OneDrive/Documents/GitHub/Ali-webguru-Portfolio/node_modules/swiper/core/slide/slideTo.js"],"names":["animateCSSModeScroll","slideTo","index","speed","runCallbacks","internal","initial","params","Error","indexAsNumber","parseInt","isValidNumber","isFinite","swiper","slideIndex","snapGrid","slidesGrid","previousIndex","activeIndex","rtl","rtlTranslate","wrapperEl","enabled","animating","preventInteractionOnTransition","skip","Math","min","slidesPerGroupSkip","snapIndex","floor","slidesPerGroup","length","initialSlide","emit","translate","updateProgress","normalizeSlideIndex","i","normalizedTranslate","normalizedGrid","normalizedGridNext","initialized","allowSlideNext","minTranslate","allowSlidePrev","maxTranslate","direction","updateActiveIndex","autoHeight","updateAutoHeight","updateSlidesClasses","effect","setTranslate","transitionStart","transitionEnd","cssMode","isH","isHorizontal","t","isVirtual","virtual","style","scrollSnapType","_immediateVirtual","requestAnimationFrame","_swiperImmediateVirtual","support","smoothScroll","targetPosition","side","scrollTo","setTransition","onSlideToWrapperTransitionEnd","e","destroyed","target","$wrapperEl","removeEventListener","addEventListener"],"mappings":"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","sourcesContent":["import { animateCSSModeScroll } from '../../shared/utils.js';\r\nexport default function slideTo(index, speed, runCallbacks, internal, initial) {\r\n  if (index === void 0) {\r\n    index = 0;\r\n  }\r\n\r\n  if (speed === void 0) {\r\n    speed = this.params.speed;\r\n  }\r\n\r\n  if (runCallbacks === void 0) {\r\n    runCallbacks = true;\r\n  }\r\n\r\n  if (typeof index !== 'number' && typeof index !== 'string') {\r\n    throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${typeof index}] given.`);\r\n  }\r\n\r\n  if (typeof index === 'string') {\r\n    /**\r\n     * The `index` argument converted from `string` to `number`.\r\n     * @type {number}\r\n     */\r\n    const indexAsNumber = parseInt(index, 10);\r\n    /**\r\n     * Determines whether the `index` argument is a valid `number`\r\n     * after being converted from the `string` type.\r\n     * @type {boolean}\r\n     */\r\n\r\n    const isValidNumber = isFinite(indexAsNumber);\r\n\r\n    if (!isValidNumber) {\r\n      throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${index}] given.`);\r\n    } // Knowing that the converted `index` is a valid number,\r\n    // we can update the original argument's value.\r\n\r\n\r\n    index = indexAsNumber;\r\n  }\r\n\r\n  const swiper = this;\r\n  let slideIndex = index;\r\n  if (slideIndex < 0) slideIndex = 0;\r\n  const {\r\n    params,\r\n    snapGrid,\r\n    slidesGrid,\r\n    previousIndex,\r\n    activeIndex,\r\n    rtlTranslate: rtl,\r\n    wrapperEl,\r\n    enabled\r\n  } = swiper;\r\n\r\n  if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {\r\n    return false;\r\n  }\r\n\r\n  const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);\r\n  let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);\r\n  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\r\n\r\n  if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {\r\n    swiper.emit('beforeSlideChangeStart');\r\n  }\r\n\r\n  const translate = -snapGrid[snapIndex]; // Update progress\r\n\r\n  swiper.updateProgress(translate); // Normalize slideIndex\r\n\r\n  if (params.normalizeSlideIndex) {\r\n    for (let i = 0; i < slidesGrid.length; i += 1) {\r\n      const normalizedTranslate = -Math.floor(translate * 100);\r\n      const normalizedGrid = Math.floor(slidesGrid[i] * 100);\r\n      const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);\r\n\r\n      if (typeof slidesGrid[i + 1] !== 'undefined') {\r\n        if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {\r\n          slideIndex = i;\r\n        } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {\r\n          slideIndex = i + 1;\r\n        }\r\n      } else if (normalizedTranslate >= normalizedGrid) {\r\n        slideIndex = i;\r\n      }\r\n    }\r\n  } // Directions locks\r\n\r\n\r\n  if (swiper.initialized && slideIndex !== activeIndex) {\r\n    if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {\r\n      return false;\r\n    }\r\n\r\n    if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {\r\n      if ((activeIndex || 0) !== slideIndex) return false;\r\n    }\r\n  }\r\n\r\n  let direction;\r\n  if (slideIndex > activeIndex) direction = 'next';else if (slideIndex < activeIndex) direction = 'prev';else direction = 'reset'; // Update Index\r\n\r\n  if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {\r\n    swiper.updateActiveIndex(slideIndex); // Update Height\r\n\r\n    if (params.autoHeight) {\r\n      swiper.updateAutoHeight();\r\n    }\r\n\r\n    swiper.updateSlidesClasses();\r\n\r\n    if (params.effect !== 'slide') {\r\n      swiper.setTranslate(translate);\r\n    }\r\n\r\n    if (direction !== 'reset') {\r\n      swiper.transitionStart(runCallbacks, direction);\r\n      swiper.transitionEnd(runCallbacks, direction);\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  if (params.cssMode) {\r\n    const isH = swiper.isHorizontal();\r\n    const t = rtl ? translate : -translate;\r\n\r\n    if (speed === 0) {\r\n      const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\r\n\r\n      if (isVirtual) {\r\n        swiper.wrapperEl.style.scrollSnapType = 'none';\r\n        swiper._immediateVirtual = true;\r\n      }\r\n\r\n      wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;\r\n\r\n      if (isVirtual) {\r\n        requestAnimationFrame(() => {\r\n          swiper.wrapperEl.style.scrollSnapType = '';\r\n          swiper._swiperImmediateVirtual = false;\r\n        });\r\n      }\r\n    } else {\r\n      if (!swiper.support.smoothScroll) {\r\n        animateCSSModeScroll({\r\n          swiper,\r\n          targetPosition: t,\r\n          side: isH ? 'left' : 'top'\r\n        });\r\n        return true;\r\n      }\r\n\r\n      wrapperEl.scrollTo({\r\n        [isH ? 'left' : 'top']: t,\r\n        behavior: 'smooth'\r\n      });\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  swiper.setTransition(speed);\r\n  swiper.setTranslate(translate);\r\n  swiper.updateActiveIndex(slideIndex);\r\n  swiper.updateSlidesClasses();\r\n  swiper.emit('beforeTransitionStart', speed, internal);\r\n  swiper.transitionStart(runCallbacks, direction);\r\n\r\n  if (speed === 0) {\r\n    swiper.transitionEnd(runCallbacks, direction);\r\n  } else if (!swiper.animating) {\r\n    swiper.animating = true;\r\n\r\n    if (!swiper.onSlideToWrapperTransitionEnd) {\r\n      swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {\r\n        if (!swiper || swiper.destroyed) return;\r\n        if (e.target !== this) return;\r\n        swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\r\n        swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);\r\n        swiper.onSlideToWrapperTransitionEnd = null;\r\n        delete swiper.onSlideToWrapperTransitionEnd;\r\n        swiper.transitionEnd(runCallbacks, direction);\r\n      };\r\n    }\r\n\r\n    swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\r\n    swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);\r\n  }\r\n\r\n  return true;\r\n}"]},"metadata":{},"sourceType":"module"}